## Redis源码分析


### 第一部分：基本数据结构


#### 1. 简单动态字符串（sds）

- sds.h
- sds.c
- zmalloc.h
- zmalloc.c

**1.1 简单动态字符串优势**

- 常数复杂度获取字符串长度
- 杜绝缓冲区溢出(strcat...)
- 修改字符串时减少内存重分配次数(采用预分配和惰性删除策略)
- 二进制空间安全(不会被'/0'截断)
- 兼容部分C字符串函数


#### 2. 链表

- adlist.h
- adlist.c

常规的双向链表，可以设置链表的复制、释放、比较函数。


#### 3. 字典

- dict.h
- dict.c
- fmacros.h(系统宏定义)
- redisassert.h(redis自定义的assert函数)

**3.1 哈希算法**
index := hash_fn(key); (fn采用MurmurHash2算法)
index := index & mask; (mask为hash表桶大小减1)

**3.2 渐进式 rehash**

**3.2.1 时机**

- 扩张：未处于落盘期间负载因子大于等于1的时候；处于落盘期间负载因子大于等于5的时候。
- 收缩：负载因子小于0.1的时候。

**3.2.2 渐进机制**

1.  将rehashidx标志置位0，表示开始迁移。
2.  置位后的每个查询、写入、删除操作之前，都先进行一段时间(1ms)数据迁移。
3.  迁移期间数据的变动全部作用于备表，查询时先查主，再查备。
4.  迁移成功后用备表替换主表，重置备表，将rehashidx置位-1。


#### 4. 跳跃表

- redis.h
- t_zset.c
- config.h(系统配置变量)
- solarisfixes.h(针对sun系统的一些宏定义)
- version.h(版本号文件)
- help.h(redis操作命令信息集合)

常规跳表实现，注意跳表是有序的。redis的跳表最多32层，每一层的大小随机产生。跳表按照score分数来排序，当分数相同时，则根据存储对象的大小来比较排序。


#### 5. 整数集合

- intset.h
- intset.c
- endianconv.h(字节序处理声明文件)
- endianconv.c(字节序处理实现文件)

整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，redis就会使用整数集合作为集合键的底层实现。整数集合的底层是一个数组，有序不重复。

**5.1 整数集合升级**

升级步骤分三步进行：

1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
2. 将原有元素进行数据转换，并放到新列表的合适位置，整个过程需要保证底层数组的有序性质不变。
3. 将新元素添加到底层数组里面。

整数集合不支持降级操作。


#### 6. 压缩列表

- ziplist.h
- ziplist.c
- zipmap.h(针对字符串实现的压缩列表，未使用)
- zipmap.c(针对字符串实现的压缩列表，未使用)
- util.h(工具函数声明)
- util.c(工具函数实现)

压缩列表是底层列表键和哈希键的底层实现之一。当一个哈希键只包含少量键值对，而且每个键值对的键和值要么是小整数值，要么就是长度比较短的字符串时，那么redis就会使用压缩列表来做哈希键的底层实现。

**6.1 连锁更新**

删除或插入元素可能引起压缩列表的连锁更新操作，其最坏时间复杂度可能达到n的平方，但是其平均复杂度为线性的，出现最坏情况的概率极低，因此一般不需要担心连锁更新的性能
常规跳表实现，注意跳表是有序的。redis的跳表最多32层，每一层的大小随机产生。跳表按照score分数来排序，当分数相同时，则根据存储对象的大小来比较排序。


#### 7. 对象

- redis.h
- object.c
- rand.h(redis随机数生成函数声明文件)
- rand.c(redis随机数生成函数实现文件)
- pqsort.h(redis在qsort的基础上实现的部分排序函数声明文件)
- pqsort.c(redis在qsort的基础上实现的部分排序函数实现文件)

redis在上面讲的几种数据结构的基础上封装了一个对象系统，该系统包含了字符串对象、列表对象、哈希对象、集合对象和有序集合对象五种类型的对象。

**7.1 对象底层实现**

- 字符串对象
	- 整形值
	- embstr编码的动态简单字符串
	- 动态简单字符串
- 列表对象
	- 压缩列表
	- 链表
- 哈希对象
	- 压缩列表
	- 哈希表
- 集合
	- 整数集合
	- 字典
- 有序集合
	- 压缩列表
	- 跳表

**7.2 字符串对象**

embstr编码的字符串将redisObject和sdshdr对象连在一起一次性分配所需的空间，这样可以将原来需要调用两次的空间分配/释放函数降为一次，而且可以充分应用缓存的优势。此外，对embstr编码字符串的任何修改都会将其转换为动态简单字符串。

**7.3 列表对象**

以下情况下使用压缩列表作为底层实现：
- 列表保存的所有字符串元素的长度都小于64字节
- 列表对象保存的元素数量小于512个

可以通过配置文件的list-max-ziplist-value和list-max-ziplist-entries修改上述限制。

**7.4 哈希对象**

以下情况下使用压缩列表作为底层实现：
- 列表保存的所有字符串元素的长度都小于64字节
- 列表对象保存的元素数量小于512个

可以通过配置文件的hash-max-ziplist-value和hash-max-ziplist-entries修改上述限制。

**7.5 集合对象**

以下情况下使用整数集合作为底层实现：
- 列表保存的所有元素都是整数值
- 列表对象保存的元素数量小于512个

可以通过配置文件的set-max-ziplist-entries修改上述限制。

**7.6 有序集合**

以下情况下使用压缩列表作为底层实现：
- 列表保存的所有字符串元素的长度都小于64字节
- 列表对象保存的元素数量小于512个

可以通过配置文件的zset-max-ziplist-value和zset-max-ziplist-entries修改上述限制。

**7.7 对象共享**

redis在初始化服务器时，创建一万个字符串对象，这个对象包含了0-9999所有整数值，当服务器需要用到值为0-9999的字符串对象时，服务器就会使用这些共享对象，而不是创建新的对象。


#### 8. 数据库

- redis.h
- redis.c
- db.c
- anet.h(redis对网络接口的封装声明文件)
- anet.c(redis对网络接口的封装实现文件)
- rio.h(redis对IO操作的封装声明)
- rio.c(redis对IO操作的封装实现)

**8.1 数据库切换**

redis服务器默认创建16个数据库，redis客户端通过select命令切换数据库。由于redis没有返回客户端目标数据库的命令，所以为了避免误操作，在执行redis危险命令之前，最好先执行下select命令，显示切换到指定的数据库，然后再执行别的命令。

**8.2 键操作**

redis数据库的每个键可以设置一个过期时间，键与过期时间的对应关系保存在数据库结构的expires字典结构里面。redis采用定期删除加惰性删除的策略来删除过期键。

**8.3 复制过程对过期键的处理**

- 当保存RDB文件时，过期键不会被保存到RDB文件中。再加载RDB文件时，如果是主服务器，那么过期键会被过滤掉；如果是从服务器，则加载到内存中，根据同步机制删除。


#### 9. RDB持久化

- lzf.h(LZF算法压缩解压函数声明文件)
- lzfP.h(LZF算法压缩解压函数声明文件)
- lzf_c.c(LZF算法压缩函数实现文件)
- lzf_d.c(LZF算法解压函数实现文件)
- rdb.h
- rdb.c
- ae.h(redis事件声明处理文件)
- ae.c(redis事件实现处理文件)
- debug.c(调试工具函数)

**9.1 创建与载入**

- save命令阻塞服务器进程，直到RDB文件创建完毕为止，阻塞期间服务器不能处理任何命令请求。
- bgsave派生出一个进程，然后又子进程负责创建RDB文件。
- redis没有载入RDB文件的命令，当redis服务器重启时，如果检测到RDB文件的存在，它就会自动载入RDB文件。
- 在bgsave执行期间，客户端发送的save命令会被服务器拒绝。
- 在bgsave执行期间，客户端发送的bgsave命令会被服务器拒绝。
- bgrewriteaof和bgsave两个命令不能同时进行。因为两个命令都会开辟一个子进程进行大量磁盘操作，严重影响性能。

**9.2 RDB文件结构**

**9.2.1 总体结构**<br/>
| REDIS | db\_version | database | EOF | check\_sum |

**9.2.2 database结构**<br/>
| SELECTDB | db_number | key\_value\_pairs |

**9.2.3 key\_value\_pairs结构**<br/>
| TYPE | key | value |<br/>
TYPE 类型如下:<br/>
REDIS\_RDB\_TYPE\_STRING<br/>
REDIS\_RDB\_TYPE\_LIST<br/>
REDIS\_RDB\_TYPE\_SET<br/>
REDIS\_RDB\_TYPE\_ZSET<br/>
REDIS\_RDB\_TYPE\_HASH<br/>
REDIS\_RDB\_TYPE\_LIST\_ZIPLIST<br/>
REDIS\_RDB\_TYPE\_SET\_INTSET<br/>
REDIS\_RDB\_TYPE\_ZSET\_ZIPLIST<br/>
REDIS\_RDB\_TYPE\_HASH\_ZIPLIST<br/>

带有过期时间的键的结构：<br/>
| EXPIRETIME\_MS | ms | TYPE | key | value |<br/>

**9.2.4 value结构**<br/>
字符串对象：<br/>
| ENCODING | integer |<br/>
| len | string |<br/>
| REDIS\_RDB\_ENC\_LZF | compressed\_len | origin\_len | compressed\_string |<br/>

列表对象：<br/>
| list\_length | item1 | item2 | ... | itemN |<br/>

集合对象：<br/>
| set\_size | item1 | item2 | ... | itemN |<br/>

哈希表对象：<br/>
| hash\_size | kv\_pair 1 | kv\_pair 2 | ... | kv\_pair N |<br/>

...


**10. AOF持久化**

- redis.h
- redis.c
- aof.c
- asciilogo.h
- bio.h(定时将系统缓存数据刷入磁盘逻辑)
- bio.c(定时将系统缓存数据刷入磁盘逻辑)

**10.1 文件写入和同步**

AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤。<br/>
- 命令追加：将执行的指令追加到内存缓冲区，执行每个命令都会追加。<br/>
- 文件写入：将内存中的数据写入到系统的磁盘缓冲区，每次循环都会写入。<br/>
- 文件同步：将磁盘缓冲区中的数据刷新到磁盘，具体看刷新策略。<br/>

文件同步：<br/>
- always<br/>
- no<br/>
- everysec<br/>

**10.2 AOF文件的载入与数据还原**

redis读取AOF文件并还原数据库状态的详细步骤如下：<br/>
1. 创建一个不带网络连接的为客户端；<br/>
2. 从AOF文件中分析并读取出一条写命令；<br/>
3. 使用伪客户端执行被读出的写命令；<br/>
4. 重复执行步骤2和步骤3，指导AOF文件中的所有写命令都被处理完毕为止。<br/>

**10.3 重写机制**

首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这条键值对的多条命令，这就是重写的实现原理。重写过程中，如果一个键包含的元素超过了64个元素，程序就会分成多次来执行。

采用子进程进行重写的好处是：<br/>
1. 子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求；<br/>
2. 子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免使用锁的情况下，保证数据的安全性。<br/>
