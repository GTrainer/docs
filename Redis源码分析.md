## Redis源码分析


### 第一部分：基本数据结构


#### 1. 简单动态字符串（sds）

- sds.h
- sds.c
- zmalloc.h
- zmalloc.c

**1.1 简单动态字符串优势**

- 常数复杂度获取字符串长度
- 杜绝缓冲区溢出(strcat...)
- 修改字符串时减少内存重分配次数(采用预分配和惰性删除策略)
- 二进制空间安全(不会被'/0'截断)
- 兼容部分C字符串函数


#### 2. 链表

- adlist.h
- adlist.c

常规的双向链表，可以设置链表的复制、释放、比较函数。


#### 3. 字典

- dict.h
- dict.c
- fmacros.h(系统宏定义)
- redisassert.h(redis自定义的assert函数)

**3.1 哈希算法**
index := hash_fn(key); (fn采用MurmurHash2算法)
index := index & mask; (mask为hash表桶大小减1)

**3.2 渐进式 rehash**

**3.2.1 时机**

- 扩张：未处于落盘期间负载因子大于等于1的时候；处于落盘期间负载因子大于等于5的时候。
- 收缩：负载因子小于0.1的时候。

**3.2.2 渐进机制**

1.  将rehashidx标志置位0，表示开始迁移。
2.  置位后的每个查询、写入、删除操作之前，都先进行一段时间(1ms)数据迁移。
3.  迁移期间数据的变动全部作用于备表，查询时先查主，再查备。
4.  迁移成功后用备表替换主表，重置备表，将rehashidx置位-1。


#### 4. 跳跃表

- redis.h
- t_zset.c
- config.h(系统配置变量)
- solarisfixes.h(针对sun系统的一些宏定义)
- version.h(版本号文件)
- help.h(redis操作命令信息集合)

常规跳表实现，注意跳表是有序的。redis的跳表最多32层，每一层的大小随机产生。跳表按照score分数来排序，当分数相同时，则根据存储对象的大小来比较排序。


#### 5. 整数集合

- intset.h
- intset.c
- endianconv.h(字节序处理声明文件)
- endianconv.c(字节序处理实现文件)

整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，redis就会使用整数集合作为集合键的底层实现。整数集合的底层是一个数组，有序不重复。

**5.1 整数集合升级**

升级步骤分三步进行：

1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
2. 将原有元素进行数据转换，并放到新列表的合适位置，整个过程需要保证底层数组的有序性质不变。
3. 将新元素添加到底层数组里面。

整数集合不支持降级操作。


#### 6. 压缩列表

- ziplist.h
- ziplist.c
- zipmap.h(针对字符串实现的压缩列表，未使用)
- zipmap.c(针对字符串实现的压缩列表，未使用)
- util.h(工具函数声明)
- util.c(工具函数实现)

压缩列表是底层列表键和哈希键的底层实现之一。当一个哈希键只包含少量键值对，而且每个键值对的键和值要么是小整数值，要么就是长度比较短的字符串时，那么redis就会使用压缩列表来做哈希键的底层实现。

**连锁更新**

删除或插入元素可能引起压缩列表的连锁更新操作，其最坏时间复杂度可能达到n的平方，但是其平均复杂度为线性的，出现最坏情况的概率极低，因此一般不需要担心连锁更新的性能
常规跳表实现，注意跳表是有序的。redis的跳表最多32层，每一层的大小随机产生。跳表按照score分数来排序，当分数相同时，则根据存储对象的大小来比较排序。


#### 7. 对象

- redis.h
- object.c
- rand.h(redis随机数生成函数声明文件)
- rand.c(redis随机数生成函数实现文件)
- pqsort.h(redis在qsort的基础上实现的部分排序函数声明文件)
- pqsort.c(redis在qsort的基础上实现的部分排序函数实现文件)
