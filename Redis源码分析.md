## Redis源码分析


### 第一部分：基本数据结构


#### 1. 简单动态字符串（sds）

- sds.h
- sds.c
- zmalloc.h
- zmalloc.c

**1.1 简单动态字符串优势**

- 常数复杂度获取字符串长度
- 杜绝缓冲区溢出(strcat...)
- 修改字符串时减少内存重分配次数(采用预分配和惰性删除策略)
- 二进制空间安全(不会被'/0'截断)
- 兼容部分C字符串函数


#### 2. 链表

- adlist.h
- adlist.c

常规的双向链表，可以设置链表的复制、释放、比较函数。


#### 3. 字典

- dict.h
- dict.c
- fmacros.h(系统宏定义)
- redisassert.h(redis自定义的assert函数)

**3.1 哈希算法**
index := hash_fn(key); (fn采用MurmurHash2算法)
index := index & mask; (mask为hash表桶大小减1)

**3.2 渐进式 rehash**

**3.2.1 时机**

- 扩张：未处于落盘期间负载因子大于等于1的时候；处于落盘期间负载因子大于等于5的时候。
- 收缩：负载因子小于0.1的时候。

**3.2.2 渐进机制**

1.  将rehashidx标志置位0，表示开始迁移。
2.  置位后的每个查询、写入、删除操作之前，都先进行一段时间(1ms)数据迁移。
3.  迁移期间数据的变动全部作用于备表，查询时先查主，再查备。
4.  迁移成功后用备表替换主表，重置备表，将rehashidx置位-1。


#### 4. 跳跃表

- redis.h
- t_zset.c
- config.h(系统配置变量)
- solarisfixes.h(针对sun系统的一些宏定义)
- version.h(版本号文件)
- help.h(redis操作命令信息集合)

常规跳表实现，注意跳表是有序的。redis的跳表最多32层，每一层的大小随机产生。跳表按照score分数来排序，当分数相同时，则根据存储对象的大小来比较排序。


#### 5. 整数集合

- intset.h
- intset.c
- endianconv.h(字节序处理声明文件)
- endianconv.c(字节序处理实现文件)

整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，redis就会使用整数集合作为集合键的底层实现。整数集合的底层是一个数组，有序不重复。

**5.1 整数集合升级**

升级步骤分三步进行：

1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
2. 将原有元素进行数据转换，并放到新列表的合适位置，整个过程需要保证底层数组的有序性质不变。
3. 将新元素添加到底层数组里面。

整数集合不支持降级操作。


#### 6. 压缩列表

- ziplist.h
- ziplist.c
- zipmap.h(针对字符串实现的压缩列表，未使用)
- zipmap.c(针对字符串实现的压缩列表，未使用)
- util.h(工具函数声明)
- util.c(工具函数实现)

压缩列表是底层列表键和哈希键的底层实现之一。当一个哈希键只包含少量键值对，而且每个键值对的键和值要么是小整数值，要么就是长度比较短的字符串时，那么redis就会使用压缩列表来做哈希键的底层实现。

**6.1 连锁更新**

删除或插入元素可能引起压缩列表的连锁更新操作，其最坏时间复杂度可能达到n的平方，但是其平均复杂度为线性的，出现最坏情况的概率极低，因此一般不需要担心连锁更新的性能
常规跳表实现，注意跳表是有序的。redis的跳表最多32层，每一层的大小随机产生。跳表按照score分数来排序，当分数相同时，则根据存储对象的大小来比较排序。


#### 7. 对象

- redis.h
- object.c
- rand.h(redis随机数生成函数声明文件)
- rand.c(redis随机数生成函数实现文件)
- pqsort.h(redis在qsort的基础上实现的部分排序函数声明文件)
- pqsort.c(redis在qsort的基础上实现的部分排序函数实现文件)

redis在上面讲的几种数据结构的基础上封装了一个对象系统，该系统包含了字符串对象、列表对象、哈希对象、集合对象和有序集合对象五种类型的对象。

**7.1 对象底层实现**

- 字符串对象
	- 整形值
	- embstr编码的动态简单字符串
	- 动态简单字符串
- 列表对象
	- 压缩列表
	- 链表
- 哈希对象
	- 压缩列表
	- 哈希表
- 集合
	- 整数集合
	- 字典
- 有序集合
	- 压缩列表
	- 跳表

**7.2 字符串对象**

embstr编码的字符串将redisObject和sdshdr对象连在一起一次性分配所需的空间，这样可以将原来需要调用两次的空间分配/释放函数降为一次，而且可以充分应用缓存的优势。此外，对embstr编码字符串的任何修改都会将其转换为动态简单字符串。

**7.3 列表对象**

以下情况下使用压缩列表作为底层实现：
- 列表保存的所有字符串元素的长度都小于64字节
- 列表对象保存的元素数量小于512个

可以通过配置文件的list-max-ziplist-value和list-max-ziplist-entries修改上述限制。

**7.4 哈希对象**

以下情况下使用压缩列表作为底层实现：
- 列表保存的所有字符串元素的长度都小于64字节
- 列表对象保存的元素数量小于512个

可以通过配置文件的hash-max-ziplist-value和hash-max-ziplist-entries修改上述限制。

**7.5 集合对象**

以下情况下使用整数集合作为底层实现：
- 列表保存的所有元素都是整数值
- 列表对象保存的元素数量小于512个

可以通过配置文件的set-max-ziplist-entries修改上述限制。

**7.6 有序集合**

以下情况下使用压缩列表作为底层实现：
- 列表保存的所有字符串元素的长度都小于64字节
- 列表对象保存的元素数量小于512个

可以通过配置文件的zset-max-ziplist-value和zset-max-ziplist-entries修改上述限制。

**7.7 对象共享**

redis在初始化服务器时，创建一万个字符串对象，这个对象包含了0-9999所有整数值，当服务器需要用到值为0-9999的字符串对象时，服务器就会使用这些共享对象，而不是创建新的对象。


#### 8. 数据库

- redis.h
- redis.c
- db.c
- anet.h(redis对网络接口的封装声明文件)
- anet.c(redis对网络接口的封装实现文件)
- rio.h(redis对IO操作的封装声明)
- rio.c(redis对IO操作的封装实现)

**8.1 数据库切换**

redis服务器默认创建16个数据库，redis客户端通过select命令切换数据库。由于redis没有返回客户端目标数据库的命令，所以为了避免误操作，在执行redis危险命令之前，最好先执行下select命令，显示切换到指定的数据库，然后再执行别的命令。

**8.2 键操作**

redis数据库的每个键可以设置一个过期时间，键与过期时间的对应关系保存在数据库结构的expires字典结构里面。redis采用定期删除加惰性删除的策略来删除过期键。

**8.3 复制过程对过期键的处理**

- 当保存RDB文件时，过期键不会被保存到RDB文件中。再加载RDB文件时，如果是主服务器，那么过期键会被过滤掉；如果是从服务器，则加载到内存中，根据同步机制删除。
